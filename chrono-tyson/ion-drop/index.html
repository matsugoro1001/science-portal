<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ion Drop v2</title>
    <!-- 物理演算ライブラリ Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        /* スタート画面のスタイル */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
        }

        #start-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: #ff00cc;
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 20px #ff00cc;
        }

        canvas {
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            border: 1px solid #333;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
            width: 300px;
        }



        #dead-line {
            position: absolute;
            top: 150px;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 0, 0, 0.3);
            border-bottom: 1px dashed red;
            pointer-events: none;
            z-index: 5;
            display: flex;
            align-items: flex-end;
            padding-left: 10px;
            color: red;
            font-size: 12px;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }

        #reaction-log {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #00ffff;
            pointer-events: none;
            z-index: 20;
            min-height: 1.2em;
            transition: opacity 0.3s ease-out;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="ui-layer">
            <div id="score-board">SCORE: <span id="score">0</span></div>
            <div id="level-display" style="font-size: 20px; font-weight: bold; margin-top: 5px;">LV: <span
                    id="level">1</span></div>
            <div id="mission-display" style="font-size: 16px; color: #ffff00; margin-top: 5px;">TARGET: <br><span
                    id="target-name">---</span></div>
            <div id="next-display" style="margin-top: 10px;">NEXT: <span id="next-name">---</span></div>
        </div>

        <div id="dead-line">DANGER LINE</div>

        <div id="reaction-log" style="opacity: 0;"></div>

        <!-- スタート画面オーバーレイ -->
        <div id="start-screen">
            <div id="start-btn">GAME START</div>
            <div
                style="margin-top: 20px; text-align: left; font-size: 14px; line-height: 1.6; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px;">
                <h3 style="margin: 0 0 10px 0; color: #ff00cc; text-align: center;">ルール</h3>
                1. 画面上の <strong>TARGET</strong>（目標）の物質を作ろう！<br>
                2. ターゲットを作るとレベルアップ！<br>
                3. <strong>ターゲット以外を作るとゴミになります。</strong><br>
                4. ターゲットを作ると、周りのゴミも消せます。<br>
                5. ラインを超えたらゲームオーバー！
            </div>
            <p style="margin-top:20px; color:#aaa;">(クリックして開始)</p>
        </div>

        <!-- ゲームオーバー画面 -->
        <div id="game-over-screen">
            <h1 style="color:red; font-size:40px;">GAME OVER</h1>
            <p>SCORE: <span id="final-score">0</span></p>
            <div id="retry-btn"
                style="margin-top:20px; padding:10px 30px; background:#fff; color:#000; cursor:pointer; font-weight:bold;">
                RETRY</div>
        </div>
    </div>

    <script>
        // --- 初期化チェック ---
        if (typeof Matter === 'undefined') {
            alert("エラー: インターネットに接続してください。\nMatter.jsライブラリが読み込めません。");
        }

        // --- 設定 ---
        const GAME_WIDTH = 380;
        const GAME_HEIGHT = 600;
        const WALL_THICKNESS = 100;
        const DEAD_LINE_Y = 150;
        const INITIAL_SPEED = 4; // 初期落下速度 (3->4)

        // イオン定義
        const IONS = [
            { name: "H⁺", charge: 1, type: 'cation', radius: 18, color: '#ff3366', pairId: 'OH' },
            { name: "OH⁻", charge: -1, type: 'anion', radius: 18, color: '#33ccff', pairId: 'OH' },
            { name: "Na⁺", charge: 1, type: 'cation', radius: 28, color: '#ff5533', pairId: 'NaCl' },
            { name: "Cl⁻", charge: -1, type: 'anion', radius: 28, color: '#33ffaa', pairId: 'NaCl' },
            { name: "Cu²⁺", charge: 2, type: 'cation', radius: 38, color: '#ff00cc', pairId: 'CuSO4' },
            { name: "SO₄²⁻", charge: -2, type: 'anion', radius: 38, color: '#00ccff', pairId: 'CuSO4' }
        ];

        // 生成物マップ (名前のペア -> 生成物名)
        const PRODUCT_MAP = [
            { pair: ['H⁺', 'Cl⁻'], name: "HCl (塩化水素)" },
            { pair: ['Na⁺', 'OH⁻'], name: "NaOH (水酸化ナトリウム)" },
            { pair: ['H⁺', 'OH⁻'], name: "H₂O (水)" },
            { pair: ['Cu²⁺', 'SO₄²⁻'], name: "CuSO₄ (硫酸銅(II))" },
            { pair: ['HSO₄⁻', 'H⁺'], name: "H₂SO₄ (硫酸)" },
            { pair: ['NaSO₄⁻', 'Na⁺'], name: "Na₂SO₄ (硫酸ナトリウム)" },
            { pair: ['Cu(OH)⁺', 'OH⁻'], name: "Cu(OH)₂ (水酸化銅(II))" },
            { pair: ['CuCl⁺', 'Cl⁻'], name: "CuCl₂ (塩化銅(II))" },
            { pair: ['Na⁺', 'Cl⁻'], name: "NaCl (塩化ナトリウム)" },
            // 複雑な塩
            { pair: ['CuCl⁺', 'OH⁻'], name: "CuCl(OH) (塩化水酸化銅(II))" },
            { pair: ['Cu(OH)⁺', 'Cl⁻'], name: "CuCl(OH) (塩化水酸化銅(II))" },
            { pair: ['HSO₄⁻', 'Na⁺'], name: "NaHSO₄ (硫酸水素ナトリウム)" },
            { pair: ['NaSO₄⁻', 'H⁺'], name: "NaHSO₄ (硫酸水素ナトリウム)" }
        ];

        // Matter.js エイリアス
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Events = Matter.Events,
            Body = Matter.Body,
            Vector = Matter.Vector;

        // エンジンセットアップ
        const engine = Engine.create();
        const world = engine.world;

        // 重力は通常通り有効にするが、操作中のイオンは制御する
        engine.gravity.y = 1;

        const container = document.getElementById('game-container');
        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: GAME_WIDTH,
                height: GAME_HEIGHT,
                wireframes: false,
                background: '#111'
            }
        });

        // 壁
        const ground = Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + WALL_THICKNESS / 2, GAME_WIDTH, WALL_THICKNESS, { isStatic: true, render: { fillStyle: '#333' }, label: 'ground' });
        const leftWall = Bodies.rectangle(0 - WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT * 2, { isStatic: true, label: 'wall' });
        const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT * 2, { isStatic: true, label: 'wall' });

        Composite.add(world, [ground, leftWall, rightWall]);

        // --- ゲーム状態 ---
        let gameActive = false;
        let score = 0;
        let level = 1;
        let currentFallSpeed = INITIAL_SPEED;
        let nextIonIndex = Math.floor(Math.random() * IONS.length);
        let currentDropper = null;
        let isDropperActive = false; // 操作中かどうか
        let targetX = GAME_WIDTH / 2; // マウス/タッチの目標X座標
        let reactionTimeout = null; // 表示タイマー管理用

        // ミッション定義（レベルごとの目標物質）
        const MISSIONS = [
            { target: "H₂O", name: "H₂O (水)" },
            { target: "NaCl", name: "NaCl (塩化ナトリウム)" },
            { target: "HCl", name: "HCl (塩化水素)" },
            { target: "NaOH", name: "NaOH (水酸化ナトリウム)" },
            { target: "CuSO₄", name: "CuSO₄ (硫酸銅(II))" },
            { target: "H₂SO₄", name: "H₂SO₄ (硫酸)" },
            { target: "Cu(OH)₂", name: "Cu(OH)₂ (水酸化銅(II))" },
            { target: "Na₂SO₄", name: "Na₂SO₄ (硫酸ナトリウム)" },
            { target: "CuCl₂", name: "CuCl₂ (塩化銅(II))" },
            { target: "NaHSO₄", name: "NaHSO₄ (硫酸水素ナトリウム)" }
        ];

        // UI更新
        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('level').innerText = level;

            // ミッション表示（ループさせる）
            const missionIndex = (level - 1) % MISSIONS.length;
            const mission = MISSIONS[missionIndex];
            const targetText = mission.name;
            document.getElementById('target-name').innerText = targetText;

            const nextData = IONS[nextIonIndex];
            const nextEl = document.getElementById('next-name');
            nextEl.innerText = nextData.name;
            nextEl.style.color = nextData.color;
            nextEl.style.textShadow = `0 0 10px ${nextData.color}`;
        }

        // ミッション達成チェック
        function checkMission(createdProductName) {
            const missionIndex = (level - 1) % MISSIONS.length;
            const mission = MISSIONS[missionIndex];

            // 生成物名にターゲットが含まれているかチェック
            if (createdProductName.includes(mission.target)) {
                level++;
                currentFallSpeed = INITIAL_SPEED + (level - 1) * 0.8; // 加速強化 (0.5 -> 0.8)

                // レベルアップ演出
                const sb = document.getElementById('level-display');
                sb.style.transform = "scale(1.5)";
                sb.style.color = "#00ff00";

                const log = document.getElementById('reaction-log');
                // 次のターゲットを表示
                const nextMissionIndex = (level - 1) % MISSIONS.length;
                const nextTarget = MISSIONS[nextMissionIndex].target;

                log.innerText = `LEVEL UP! NEXT: ${nextTarget}`;
                log.style.opacity = 1;

                setTimeout(() => {
                    sb.style.transform = "scale(1)";
                    sb.style.color = "white";
                    log.style.opacity = 0;
                }, 2000);
            }
        }

        function showReaction(name) {
            const log = document.getElementById('reaction-log');

            // 前のタイマーがあればキャンセル
            if (reactionTimeout) {
                clearTimeout(reactionTimeout);
            }

            log.innerText = name;
            log.style.opacity = 1;
            // アニメーション削除：単純に表示するだけにする

            // 数秒後に消す
            reactionTimeout = setTimeout(() => {
                log.style.opacity = 0;
            }, 4000);
        }

        // イオン作成ヘルパー
        function createIonBody(x, y, index, isStatic) {
            const data = IONS[index];
            return Bodies.circle(x, y, data.radius, {
                restitution: 0.3,
                friction: 0.1,
                density: 0.002,
                isStatic: isStatic,
                label: 'ion',
                plugin: { ionData: data },
                render: {
                    fillStyle: data.color,
                    strokeStyle: '#fff',
                    lineWidth: 2
                }
            });
        }

        // スポーン処理（シングル）
        function spawnDropper() {
            if (!gameActive) return;

            // 画面中央上部に配置（Dynamic Bodyとして生成）
            currentDropper = createIonBody(GAME_WIDTH / 2, 0, nextIonIndex, false);

            Composite.add(world, currentDropper);
            isDropperActive = true;
            targetX = GAME_WIDTH / 2;

            // 次の抽選
            nextIonIndex = Math.floor(Math.random() * IONS.length);
            updateUI();
        }

        // 回転処理 (このバージョンでは使用しない)
        // function rotatePair() {
        //     if (!gameActive || !isDropperActive || !currentPair) return;
        //     currentPair.rotation = (currentPair.rotation + 1) % 4;
        // }

        // --- 操作イベント ---
        function handleInput(clientX) {
            if (!gameActive || !isDropperActive) return;
            const rect = render.canvas.getBoundingClientRect();
            targetX = clientX - rect.left;
        }

        // クリックで回転 (このバージョンでは使用しない)
        window.addEventListener('click', (e) => {
            // スタート画面やリトライボタン以外でのクリック
            if (e.target.id !== 'start-btn' && e.target.id !== 'retry-btn') {
                // rotatePair(); // シングルイオンなので回転はなし
            }
        });

        window.addEventListener('pointermove', (e) => handleInput(e.clientX));
        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); // スクロール防止
            handleInput(e.touches[0].clientX);
        }, { passive: false });

        // タップで回転（touchstartだと移動と被る可能性あるが、簡易的に） (このバージョンでは使用しない)
        window.addEventListener('touchstart', (e) => {
            // 移動操作と区別するため、少し判定が必要だが、
            // ここではシンプルに「タップ＝回転」とする（移動はtouchmove）
            // ただし、start-btn等は除外
            if (e.target.id !== 'start-btn' && e.target.id !== 'retry-btn') {
                // rotatePair(); // シングルイオンなので回転はなし
            }
        });

        // --- ゲームループ（物理演算前の制御） ---
        Events.on(engine, 'beforeUpdate', () => {
            if (!gameActive) return;

            if (isDropperActive && currentDropper) {
                // 1. X座標の制御（マウス位置に追従させる）
                // 壁を突き抜けないように制限
                const r = currentDropper.circleRadius;
                const clampedX = Math.max(r, Math.min(targetX, GAME_WIDTH - r));

                // 現在位置から目標位置へスムーズに移動させる（速度制御）
                const dx = clampedX - currentDropper.position.x;

                // 2. Y座標の制御（一定速度で落下）
                // 重力の影響を上書きして、一定速度で降ろす
                Body.setVelocity(currentDropper, {
                    x: dx * 0.2, // X方向は少し遅延させて追従
                    y: currentFallSpeed // 可変速度で落下
                });

                // 回転を止める（操作しやすくするため）
                Body.setAngularVelocity(currentDropper, 0);
            }
        });

        // --- 衝突判定（着地判定） ---
        Events.on(engine, 'collisionStart', (event) => {
            const removedBodies = new Set();

            event.pairs.forEach((pair) => {
                const A = pair.bodyA;
                const B = pair.bodyB;

                // 操作中のイオンが何かにぶつかったら操作終了（着地）
                if (isDropperActive && currentDropper) {
                    if (A === currentDropper || B === currentDropper) {
                        // 壁との衝突は無視（滑らせるため）
                        const other = A === currentDropper ? B : A;
                        if (other.label !== 'wall') {
                            // 地面か他のイオンにぶつかったら着地とみなす
                            isDropperActive = false;
                            currentDropper = null;

                            // 次のスポーンを予約
                            setTimeout(spawnDropper, 500);
                        }
                    }
                }

                // --- 反応ロジック ---
                if (removedBodies.has(A.id) || removedBodies.has(B.id)) return;

                if (A.label === 'ion' && B.label === 'ion') {
                    const dA = A.plugin.ionData;
                    const dB = B.plugin.ionData;

                    // 1. 完全中和（電荷の和が0）チェック
                    if (dA.charge + dB.charge === 0) {
                        Composite.remove(world, [A, B]);
                        removedBodies.add(A.id);
                        removedBodies.add(B.id);

                        let points = 150;
                        if (dA.isIntermediate || dB.isIntermediate) {
                            points = 500;
                        }
                        score += points;

                        // 生成物名の表示
                        const names = [dA.name, dB.name].sort();
                        const product = PRODUCT_MAP.find(p =>
                            (p.pair[0] === dA.name && p.pair[1] === dB.name) ||
                            (p.pair[0] === dB.name && p.pair[1] === dA.name)
                        );

                        if (product) {
                            showReaction(product.name);

                            const missionIndex = (level - 1) % MISSIONS.length;
                            const mission = MISSIONS[missionIndex];
                            const isTarget = product.name.includes(mission.target);

                            if (isTarget) {
                                // 正解！ -> 消える & レベルアップ
                                checkMission(product.name);

                                // ボーナス：周囲のゴミを消す
                                const explosionRadius = 120; // 爆発範囲縮小 (150 -> 120)
                                const midX = (A.position.x + B.position.x) / 2;
                                const midY = (A.position.y + B.position.y) / 2;
                                const bodies = Composite.allBodies(world);
                                const debris = bodies.filter(b => {
                                    if (b.label !== 'debris') return false;
                                    const dist = Vector.magnitude(Vector.sub(b.position, { x: midX, y: midY }));
                                    return dist < explosionRadius;
                                });
                                if (debris.length > 0) {
                                    Composite.remove(world, debris);
                                    score += debris.length * 100;
                                    const log = document.getElementById('reaction-log');
                                    // log.innerText += ` + CLEAN!`; // 表示が長くなるのでカット
                                }
                            } else {
                                // 不正解（ターゲット以外） -> ゴミになる
                                const midX = (A.position.x + B.position.x) / 2;
                                const midY = (A.position.y + B.position.y) / 2;

                                const debris = Bodies.rectangle(midX, midY, 40, 40, {
                                    restitution: 0.1,
                                    friction: 0.5,
                                    density: 0.01, // 重くする (0.005 -> 0.01)
                                    label: 'debris',
                                    render: {
                                        fillStyle: '#666',
                                        strokeStyle: '#aaa',
                                        lineWidth: 1
                                    }
                                });
                                Composite.add(world, debris);
                            }
                        }
                        else {
                            showReaction("Reaction!");
                        }

                        // 演出
                        const sb = document.getElementById('score-board');
                        sb.style.transform = "scale(1.5)";
                        sb.style.color = points >= 500 ? "#ff00ff" : "#ffff00";
                        setTimeout(() => {
                            sb.style.transform = "scale(1)";
                            sb.style.color = "white";
                        }, 200);

                        updateUI();
                        return;
                    }

                    // 2. 中間生成（マージ）チェック
                    const rule = MERGE_RULES.find(r =>
                        (r.pair[0] === dA.name && r.pair[1] === dB.name) ||
                        (r.pair[0] === dB.name && r.pair[1] === dA.name)
                    );

                    if (rule) {
                        const newIonData = rule.result;
                        const midX = (A.position.x + B.position.x) / 2;
                        const midY = (A.position.y + B.position.y) / 2;

                        Composite.remove(world, [A, B]);
                        removedBodies.add(A.id);
                        removedBodies.add(B.id);

                        const newBody = Bodies.circle(midX, midY, newIonData.radius, {
                            restitution: 0.3,
                            friction: 0.1,
                            density: 0.002,
                            label: 'ion',
                            plugin: { ionData: newIonData },
                            render: {
                                fillStyle: newIonData.color,
                                strokeStyle: '#fff',
                                lineWidth: 3,
                                lineDash: [5, 5]
                            }
                        });

                        Composite.add(world, newBody);
                    }
                }
            });
        });

        // --- ゲームオーバー判定ループ ---
        function gameLoop() {
            if (!gameActive) return;

            // デッドライン判定
            const bodies = Composite.allBodies(world);
            const isGameOver = bodies.some(b => {
                return b.label === 'ion' &&
                    b !== currentDropper && // 操作中のものは除く
                    b.position.y < DEAD_LINE_Y && // ラインより上
                    b.speed < 0.2 && // 静止している
                    Math.abs(b.velocity.y) < 0.1;
            });

            if (isGameOver) {
                gameOver();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function resetGame() {
            Composite.clear(world);
            Engine.clear(engine);
            Composite.add(world, [ground, leftWall, rightWall]);

            score = 0;
            level = 1;
            currentFallSpeed = INITIAL_SPEED;
            updateUI();
            document.getElementById('game-over-screen').style.display = 'none';
            gameActive = true;
            spawnDropper();
            gameLoop();
        }

        // --- スタート処理 ---
        document.getElementById('start-screen').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            gameActive = true;
            Render.run(render);
            const runner = Runner.create();
            Runner.run(runner, engine);
            spawnDropper();
            updateUI();
            gameLoop();
        });

        document.getElementById('retry-btn').addEventListener('click', resetGame);

        // 中間生成物の定義
        const MERGE_RULES = [
            { pair: ['H⁺', 'SO₄²⁻'], result: { name: "HSO₄⁻", charge: -1, type: 'anion', radius: 42, color: '#d4af37', isIntermediate: true } },
            { pair: ['Na⁺', 'SO₄²⁻'], result: { name: "NaSO₄⁻", charge: -1, type: 'anion', radius: 45, color: '#d4af37', isIntermediate: true } },
            { pair: ['Cu²⁺', 'OH⁻'], result: { name: "Cu(OH)⁺", charge: 1, type: 'cation', radius: 42, color: '#8a2be2', isIntermediate: true } },
            { pair: ['Cu²⁺', 'Cl⁻'], result: { name: "CuCl⁺", charge: 1, type: 'cation', radius: 45, color: '#20b2aa', isIntermediate: true } }
        ];

        // --- 文字描画 ---
        Events.on(render, 'afterRender', () => {
            const ctx = render.context;
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#fff";

            Composite.allBodies(world).forEach(body => {
                if (body.label === 'ion') {
                    const text = body.plugin.ionData.name;
                    ctx.fillText(text, body.position.x, body.position.y);
                }
            });
        });
    </script>
</body>

</html>